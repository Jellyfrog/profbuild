#! /usr/bin/env python
# Copyright (c) 2012 Nokia Corporation
# Original author John Ankcorn
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

from __future__ import print_function
import datetime, errno, json, glob, os, re, select, shutil, signal, string, subprocess, sys, time
#import createrepo
import customization, rpmrepo, sourcerepo, ParseOBS, ParseService
IDLE_THRESHOLD=0.02
WAIT_THRESHOLD=0.10
WAIT_COUNT=5
max_rpmbuild_in_seconds = 1000
TOP_DIR=os.getcwd() + '/sandbox'
TEMP_DIR= TOP_DIR + '/bbgeneric/bb'
MAX_TEMP_ID=140
memoized_block = {}
source_packages = {}
elapsed_time = {}
extractpackagename = re.compile(r'([\w\-]+?)-\d.+')

def cleandir(index):
    try:
        subprocess.call(customization.sudoprog + ' rm -rf ' + TEMP_DIR + index + ' 2>/dev/null', shell=True)
    except:
        pass
    try:
        subprocess.call(customization.sudoprog + ' rm -rf ' + TOP_DIR + '/bb' + index + ' 2>/dev/null', shell=True)
    except:
        pass

def extend_damage(blocked_list, damages, damaged, indent):
    verbose = 0
    for tpack in rpmrepo.packagelist:
        mtemp = tpack.get('rpm:sourcerpm')
        if mtemp is not None:
            mtemp = extractpackagename.match(mtemp)
        if mtemp and mtemp.group(1) == damaged and tpack.get('rpm:provides') is not None:
            # tpack is an RPM generated by something that was 'damaged'
            if verbose > 0:
                print(indent, 'package', damaged, 'generates RPM', tpack.get('name'), tpack.get('rpm:provides'))
            for pprov in tpack['rpm:provides']:
                # for each of the 'provides' that it supplies, find which SRPMs 'require' them
                if source_packages.get(pprov) is None:
                    continue
                for packname in source_packages[pprov]:
                    # add the source package name to the list of 'blocked'
                    if damages is not None and packname not in damages:
                        damages.append(packname)
                    if packname != damaged and packname not in blocked_list:
                        if verbose > 0:
                            print(indent, 'damaged package', pprov, 'pack', packname, blocked_list, damages)
                        blocked_list.append(packname)
                        if memoized_block.get(packname) is None:
                            memoized_block[packname] = []
                            extend_damage(memoized_block[packname], [], packname, indent + '    ')
                        for packname in memoized_block.get(packname):
                            if packname not in blocked_list:
                                blocked_list.append(packname)

def add_schedule(scheduleitem, aname):
    class ScheduleItem:
        def __init__(self, name):
            self.name = name
            self.weight = 0
            self.running = 'wait'
            self.blocked_list = []
            self.damages = []
    for item in scheduleitem.examined_list:
        if item == aname:
            # only compile a package 1 time per run
            return
    sitem = ScheduleItem(aname)
    scheduleitem.schedule_list.append(sitem)
    scheduleitem.examined_list.append(aname)
    extend_damage(sitem.blocked_list, sitem.damages, aname, '')

def find_weight(scheduleitem, item):
    if item.weight == 0:
        # prevent recursion
        item.weight = 1
        weight = 0
        for citem in scheduleitem.schedule_list:
            if citem.name in item.blocked_list:
                #print('dddd', item.name, citem.name, weight)
                weight += find_weight(scheduleitem, citem)
        #print('ddrrr', item.name, weight)
        etime = elapsed_time.get(item.name)
        #print('etime', item.name, etime)
        if etime:
            weight += etime / 3
        item.weight = int(weight + 1)
    return item.weight

class ScheduleClass:
    schedule_list = []
    waiting_list = []
    examined_list = []

def process(logging_active, params, projectname, itemlist):
    global elapsed_time
    ids = range(0,MAX_TEMP_ID)
    trpmdir = rpmrepo.translate_reponame('localrpm') + '/'
    if os.path.exists(TOP_DIR + '/bb.lockfile'):
        os.remove(TOP_DIR + '/bb.lockfile')
    active_processes = []
    sspl_last = None
    logdir = 'logs.armv7hl'
    if not os.path.exists(logdir):
        os.makedirs(logdir, 0o777)
    cleandir('[0-9]*')
    forcerepomd = False
    context = sourcerepo.PackageContext([TOP_DIR + '/bb0master', 'armv7hl', projectname], 0, 'i586', forcerepomd)
    for tpack in rpmrepo.packagelist:
        if tpack.get('rpm:sourcerpm') is None and tpack.get('rpm:requires'):
            #print('sourcep', tpack['name'], tpack['rpm:requires'])
            for pprov in tpack['rpm:requires']:
                 if source_packages.get(pprov) is None:
                     source_packages[pprov] = []
                 source_packages[pprov].append(tpack['name'])
    scheduleitem = ScheduleClass()
    if os.path.exists('xx.elapsed'):
        fh = open('xx.elapsed')
        elapsed_time = json.load(fh)
        fh.close()
    for item in itemlist:
        add_schedule(scheduleitem, item)
    for item in scheduleitem.schedule_list:
        find_weight(scheduleitem, item)
        #print('weight', item.weight, '\t' + item.name)
    wait_counter = 0
    while scheduleitem.schedule_list or active_processes:
        did_nothing = True
        statitem = open('/proc/stat').readlines()
        sspl = statitem[0].split()[1:]
        i = 1
        for i, item in enumerate(statitem):
            if item.startswith('cpu'):
               customization.job_count = 1.5 * i
        run_new_task = False
        if sspl_last is None:
            sspl_last = sspl
        elif scheduleitem.schedule_list and ids and len(active_processes) <= customization.job_count:
            total = 1
            for i in range(0, len(sspl_last)):
                sspl_last[i] = int(sspl[i]) - int(sspl_last[i])
                total = total + sspl_last[i]
            waiting = sspl_last[4] / float(total)
            total = sspl_last[3] / float(total)
            sspl_last = sspl
            if waiting > WAIT_THRESHOLD:
                wait_counter = 0
                #print('waiting', waiting)
            elif wait_counter  < WAIT_COUNT:
                wait_counter += 1
            elif total > IDLE_THRESHOLD:
                wait_counter = 0
                sched_item = None
                sched_len = int(-1)
                fh = open('xx.schedule', 'w')
                for iindex, item in enumerate(scheduleitem.schedule_list):
                    if item.running != 'wait':
                        continue
                    litem = str(item.weight) + ' ' + item.name + ':'
                    schedule_me = True
                    for citem in scheduleitem.schedule_list:
                        if citem != item and item.name in citem.blocked_list:
                            #print('item', item.name, 'blocked by', citem.name)
                            schedule_me = False
                            litem += ' ' + citem.name
                            #break
                    if not schedule_me:
                        fh.write(litem + '\n')
                    elif item.weight > sched_len:
                        sched_item = iindex
                        sched_len = item.weight
                fh.close()
                if sched_item is not None:
                    sitem = scheduleitem.schedule_list[sched_item]
                    sitem.running = 'run'
                    #print('can schedule', sched_item, scheduleitem.schedule_list[sched_item].name, len(scheduleitem.schedule_list[sched_item].damages))
                    run_new_task = True
                elif active_processes == []:
                    # we are stuck
                    break
        if run_new_task:
            nextitem = sitem.name
            servicefile = ''
            buildproject = projectname
            buildpackagename = nextitem
            while True:
                linkfile = ''
                mfh = ParseOBS.ParsePackage(customization.buildbase + buildproject + '/' + buildpackagename + '._manifest').filelist
                for masterline in mfh:
                    zztarget, zztemp1, actfile, zztemp2 = masterline.split()
                    actfile = customization.buildbase + '../' + actfile
                    if zztarget == '_service':
                        servicefile = actfile
                    if zztarget == '_link':
                        linkfile = actfile
                buildproject, buildpackagename = ParseOBS.ParsePackageLink(linkfile, buildproject).linkproject()
                if buildpackagename is None:
                    break
            curitem = ParseService.ParseService(0, servicefile, False).servicelist
            checkitems = []
            while curitem is not None:
                if curitem.data['url'] != '':
                     checkitems.append(curitem.data['url'])
                curitem = curitem.next
            skip_execution = False
            for lockedfile in glob.glob(TOP_DIR + '/bb*/bb*/build.servicing'):
                try:
                    for zzitem in open(lockedfile).readlines():
                        if zzitem[:-1] in checkitems:
                             print("found locking", zzitem[:-1], 'in', lockedfile)
                             sitem.running = 'locked'
                             scheduleitem.waiting_list.append((sitem, lockedfile))
                             run_new_task = False
                             break
                except:
                    pass
                if not run_new_task:
                    break
        if run_new_task:
            print('*********************** ', nextitem, time.strftime('%X'))
            thisid = ids.pop(0)
            cleandir(str(thisid))
            filename = None
            outfile = sys.stdout
            if logging_active > 0:
                filename = logdir + '/' + nextitem + '.log'
                outfile = open(filename, 'w')
            cmd = [os.path.dirname(os.path.abspath(__file__)) + '/packbuild.py']
            for item in params:
                cmd.append(item)
            chrootdir = TEMP_DIR
            if nextitem in customization.need_unique_chroot:
                chrootdir = TOP_DIR + '/bb' + str(thisid) + '/bb'
            for item in [chrootdir + str(thisid), 'armv7hl', projectname, nextitem]:
                cmd.append(item)
            p = subprocess.Popen(cmd, stdout=outfile, stderr=outfile, preexec_fn=os.setsid)
            p.starttime = datetime.datetime.utcnow()
            p.name = nextitem
            p.id = thisid
            p.chrootdir = chrootdir
            p.sitem = sitem
            active_processes.append(p)
            p.outfile = outfile
            p.filename = filename
            while not os.path.exists(os.path.dirname(TEMP_DIR) + '/inprocess') and p.poll() is None:
                select.select([], [], [], 0.1)
            did_nothing = False
        for p in active_processes:
            if p.poll() is not None:
                lfile = TOP_DIR + '/bb.lockfile'
                if os.path.exists(lfile):
                    try:
                        data = open(lfile).read()
                        if data == str(p.pid):
                            os.remove(lfile)
                    except:
                        pass
                active_processes.remove(p)
                ids.append(p.id)
                scheduleitem.schedule_list.remove(p.sitem)
                elapsed_time[p.sitem.name] = (datetime.datetime.utcnow() - p.starttime).seconds
                try:
                    lockfile = os.path.dirname(TEMP_DIR) + '/gglock'
                    data = open(lockfile).read().split()
                    if data[0] == str(p.pid):
                        print('ERROR: lockfile remains', data)
                        os.remove(lockfile)
                    else:
                        print('INFO: lockfile remains', data, p.pid)
                except:
                    pass
                if p.returncode == 0:
                    updated_output = False
                    # Success: print(all the generated RPM files)
                    clogfile = sys.stdout
                    if p.filename is not None:
                        clogfile = p.outfile
                    for pproot, ppdirs, ppfiles in os.walk(p.chrootdir + str(p.id) + '/RPMS'):
                        for ppfile in ppfiles:
                            if ppfile.endswith('.rpm'):
                                rpath = os.path.join(pproot, ppfile)
                                #print("rpm:", rpath)
                                rdir = os.path.basename(pproot)
                                if not os.path.exists(trpmdir + rdir):
                                    os.makedirs(trpmdir + rdir)
                                if ppfile.endswith('.src.rpm'):
                                    print('sourcerpm', ppfile)
                                    shutil.copy(rpath, os.path.join(trpmdir, rdir, ppfile))
                                    pass
                                else:
                                    #print(customization.scripthome + '/build-compare/rpm-check.sh last.rpms/' + rdir + '/' + ppfile + ' ' + rpath)
                                    nfile = os.path.join(trpmdir, rdir, ppfile)
                                    if os.path.exists(nfile):
                                        cret = subprocess.call(customization.scripthome + '/build-compare/rpm-check.sh ' + nfile + ' ' + rpath + ' </dev/null', shell=True, stdout=clogfile, stderr=clogfile)
                                    else:
                                        cret = 2
                                    print('rpm compare returnval', cret, 'for', ppfile)
                                    if cret != 0:
                                        updated_output = True
                                        shutil.copy(rpath, nfile)
                    if updated_output:
                        print('Info:', p.sitem.name, 'generated changed RPMs, damages', p.sitem.damages)
                        for item in p.sitem.damages:
                            add_schedule(scheduleitem, item)
                        #print('Createrepometadata', customization.scripthome + '/createrepo/genpkgmetadata.py --verbose --update ' + trpmdir)
                        subprocess.call(customization.scripthome + '/createrepo/genpkgmetadata.py --quiet --update ' + trpmdir, cwd=trpmdir, shell=True)
                        #context.packagecache.rebuild()
                else:
                    # Failure: if 'context.verbose', dump the config.log, allowing easier debugging of config errors
                    #if context.verbose > 4:
                    if False:
                        for pproot, ppdirs, ppfiles in os.walk(p.chrootdir + str(p.id)):
                            for ppfile in ppfiles:
                                if ppfile == 'config.log':
                                    fh = open(os.path.join(pproot, ppfile))
                                    inp = fh.readlines()
                                    for ppline in inp:
                                        if ppline.find('Cache variables') > 0:
                                            break
                                        print(ppline.strip())
                                    fh.close()
                ll = ''
                if p.filename is not None:
                    p.outfile.close()
                    try:
                        line = open(p.filename).readlines().pop()
                        ll = 'log: ' + line.rstrip('\n')
                    except:
                        pass
                    cleandir(str(p.id))
                elif os.path.exists(p.chrootdir + str(p.id)):
                    subprocess.call(customization.sudoprog + ' chmod -R a+rw ' + p.chrootdir + str(p.id), shell=True)
                print(len(scheduleitem.schedule_list), ll, 'finish', p.name, p.returncode, 'id', p.id, 'pid', p.pid)
                did_nothing = False
                #give the scheduler a chance
                break
        if did_nothing:
            for sindex, sitem in enumerate(scheduleitem.waiting_list):
                # if we had a conflict with git repos from service files
                # and it is now resolved, go back to 'waiting to be run' state
                if not os.path.exists(sitem[1]):
                    sitem[0].running = 'wait'
                    scheduleitem.waiting_list.pop(sindex)
            select.select([], [], [], 0.1)
    # see if we exited because we were stuck
    if scheduleitem.schedule_list:
        print('cant run anything')
        for temp in scheduleitem.schedule_list:
            bstr = ''
            for citem in scheduleitem.schedule_list:
                if citem != temp and temp.name in citem.blocked_list:
                    bstr = bstr + ' ' + citem.name
            print('remaining', temp.name, 'blocked by', bstr)
    fh = open('xx.elapsed', 'w')
    json.dump(elapsed_time, fh)
    fh.close()

def signal_handler(signal, frame):
    print('CTRLC: master.py terminating')
    subprocess.call(customization.scripthome + '/proftop.py -q', shell=True)
    sys.exit(0)

def main(aargv):
    logging_active = 0
    argindex = 1
    params = []
    projectname = None
    signal.signal(signal.SIGINT, signal_handler)
    while argindex < len(aargv) and aargv[argindex][0] == '-':
        if aargv[argindex] == '-v':
            params.append(aargv[argindex])
        if aargv[argindex] == '-l':
            logging_active += 1
        if aargv[argindex] == '-p':
            argindex += 1
            projectname = aargv[argindex]
        argindex += 1
    print('*********************** START', time.strftime('%X'))
    starttime = datetime.datetime.utcnow()
    process(logging_active, params, projectname, aargv[argindex:])
    starttime = (datetime.datetime.utcnow() - starttime).seconds
    mintime = starttime // 60
    print('*********************** DONE', str(mintime) + ':' + str(starttime - mintime * 60))
    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv))
